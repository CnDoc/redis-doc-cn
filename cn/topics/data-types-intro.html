<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <link href='../styles.css%3F1333128600.css' rel='stylesheet' type='text/css' />
    <link href='../images/favicon.png' rel='shortcut icon' />
    <link href='../opensearch.xml' rel='search' title='Look up a Redis command' type='application/opensearchdescription+xml' />
    <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js'></script>
    <script async='async' defer='defer' src='../app.js%3F1375789679'></script>
    <meta content='width=device-width, minimum-scale=1.0, maximum-scale=1.0' name='viewport' />
    <title>
      An introduction to Redis data types and abstractions – Redis
    </title>
  </head>
  <body class='topics data-types-intro'><style type="text/css">#modify_div {position: fixed;right: 0px;top: 60px;	background-color: #000000;	height: 30px;width: 100px;border-top-width: 2px;border-right-width: 2px;border-bottom-width: 2px;border-left-width: 2px;border-top-style: dashed;border-right-style: none;border-bottom-style: dashed;border-left-style: dashed;border-top-color: #333333;border-right-color: #333333;border-bottom-color: #333333;border-left-color: #333333;}#modify {display: block;position: fixed;right: 23px;top: 70px;color: #FFFFFF;text-decoration: none;font-size: 12px;font-weight: bold;}#modify:hover {text-decoration: underline;}</style><div id="modify_div"></div><a href="https://github.com/jialechan/redis-doc-cn/edit/gh-pages/cn/topics/data-types-intro.html" id="modify" target="_blank">修改本页</a><script>$('#modify_div').css('opacity', '0.6');	</script>
    <header>
      <div class='container'>
        <a href='../index.html'>
          <img alt='Redis' height='30' src='../images/redis.png' width='93' />
        </a>
        <nav>
          <a href='../commands.html'>命令</a>
          <a href='../clients.html'>客户端</a>
          <a href='../documentation.html'>文档</a>
          <a href='../community.html'>社区</a>
          <a href='../download.html'>下载</a>
          <a href='https://github.com/antirez/redis/issues'>问题</a>
          <a href='../support.html'>帮助</a>
          <a href='license.html'>许可</a>
        </nav>
      </div>
    </header>
    <div class='text'>
      <article id='topic'>
        <h1>Redis的数据类型和抽象的介绍</h1>
        
        <p>Redis不是一个<em>单纯</em>的键-值存储, 事实上她是一个<em>数据结构服务器</em>, 支持不同类型的值。这意味着，在传统的键-值key-value存储里，你关联的是一个字符串键到一个字符串值, 而在
        Redis里值不限制为一个简单的字符串，还可以是一些更加复杂的数据结构。
        下面列出了全部Redis支持的数据结构，他们会在这篇教程里被逐一介绍:</p>
        
        <ul>
        <li>Binary-safe strings.</li>
        <li>Lists: collections of string elements sorted according to the order of insertion. They are basically <em>linked lists</em>.</li>
        <li>Sets: collections of unique, unsorted string elements.</li>
        <li>Sorted sets, similar to Sets but where every string element is associated to a
        floating number value, called <em>score</em>. The elements are always taken sorted
        by their score, so unlike Sets it is possible to retrieve range of elements
        (for example you may aks: give me the top 10, or the bottom 10).</li>
        <li>Hashes, which are maps composed of fields associated with values. Both the
        field and the value are strings. This are very similary to Ruby or Python
        hashes.</li>
        <li>Bit arrays (or simply bitmaps): it is possible, usign special commands, to
        handle String values like array of bits: you can set and clear individual
        bits, count all the bits set to 1, find the first set or unset bit, and so
        forth.</li>
        <li>HyperLogLogs: this is a probabilistic data structure which is used in order
        to estimate the cardinality of a set. Don&#39;t be scared, it is simpler than
        it seems... See later in the HyperLogLog section of this tutorial.</li>
        </ul>
        
        <p>It&#39;s not always trivial to grasp how these data types work and what to use in
        order to solve a given problem from the <a href="../commands.html">command reference</a>, so this
        document is a crash course to Redis data types and their most used patterns.</p>
        
        <p>For all the examples we&#39;ll use the <code>redis-cli</code> utility, that&#39;s a simple but
        handy command line utility to issue commands against the Redis server.</p>
        
        <h2>Redis keys</h2>
        
        <p>Redis keys are binary safe, this means that you can use any binary sequence as a
        key, from a string like &quot;foo&quot; to the content of a JPEG file.
        The empty string is also a valid key.</p>
        
        <p>A few other rules about keys:</p>
        
        <ul>
        <li>Too long keys are not a good idea, for instance a key of 1024 bytes is not a
        good idea not only memory-wise, but also because the lookup of the key in the
        dataset may require several costly key-comparisons. Even when the task at hand
        is to match the existence of a big value, to resort to hashing it (for example
        with SHA1) is a better idea, especially from the point of view of memory
        and bandwidth.</li>
        <li>Too short keys are often not a good idea. There is little point in writing
        &quot;u1000flw&quot; as key if you can write instead &quot;user:1000:followers&quot;, the latter
        is more readable and the added space is little compared to the space used by
        the key object itself and the value object. However it is not possible to deny
        that short keys will consume a bit less memory. Your job is to find the
        right balance.</li>
        <li>Try to stick with a schema. For instance &quot;object-type:id&quot; can be a nice
        idea, like in &quot;user:1000&quot;. Dots or dashes are often used for multi-words
        fields, like in &quot;comment:1234:reply.to&quot; or &quot;comment:1234:reply-to&quot;.</li>
        <li>The maximum allowed key size is 512 MB.</li>
        </ul>
        
        <p><a name="strings"></a></p>
        
        <h2>Redis Strings</h2>
        
        <p>The Redis String type is the simplest type of value you can associate to
        a Redis key. It is the only data type in Memcached, so it is also very natural
        for newcomers to use it in Redis.</p>
        
        <p>Since Redis keys are strings, when we use the string type as a value too,
        we are mapping a string to another string. The string data type is useful
        for a number of use cases, like caching HTML fragments or pages.</p>
        
        <p>Let&#39;s play a bit with the string type, using <code>redis-cli</code> (all the examples
        will be performed via <code>redis-cli</code> in this tutorial).</p>
        
        <pre><code>&gt; set mykey somevalue&#x000A;OK&#x000A;&gt; get mykey&#x000A;&quot;somevalue&quot;&#x000A;</code></pre>
        
        <p>As you can see using the <a href="../commands/set.html">SET</a> and the <a href="../commands/get.html">GET</a> commands are the way we set
        and retrieve a string value. Note that <a href="../commands/set.html">SET</a> will replace any existing value
        stored already into the key, in case the key already exists, even if the key
        is associated with a non-string value. So <a href="../commands/set.html">SET</a> performs an assignment.</p>
        
        <p>Values can be strings (including binary data) of every kind, for instance you
        can store a jpeg image inside a key. A value can&#39;t be bigger than 512 MB.</p>
        
        <p>The <a href="../commands/set.html">SET</a> command has interesting options, that are provided as additional
        arguments. For example if I may ask <a href="../commands/set.html">SET</a> to fail if the key already exists,
        or the exact contrary, that is, to only succeed if the key already exists:</p>
        
        <pre><code>&gt; set mykey newval nx&#x000A;(nil)&#x000A;&gt; set mykey newval xx&#x000A;OK&#x000A;</code></pre>
        
        <p>Even if strings are the basic values of Redis, there are interesting operations
        you can perform with them. For instance, one is atomic increment:</p>
        
        <pre><code>&gt; set counter 100&#x000A;OK&#x000A;&gt; incr counter&#x000A;(integer) 101&#x000A;&gt; incr counter&#x000A;(integer) 102&#x000A;&gt; incrby counter 50&#x000A;(integer) 152&#x000A;</code></pre>
        
        <p>The <a href="../commands/incr.html">INCR</a> command parses the string value as an integer,
        increments it by one, and finally sets the obtained value as the new value.
        There are other similar commands like <a href="../commands/incrby.html">INCRBY</a>,
        <a href="http://redis.io/topics/commands/decr">DECR</a> and <a href="../commands/decrby.html">DECRBY</a>.  Internally it&#39;s
        always the same command, acting in a slightly different way.</p>
        
        <p>What does it mean that INCR is atomic?
        That even multiple clients issuing INCR against
        the same key will never incur into a race condition. For instance it can never
        happen that client 1 read &quot;10&quot;, client 2 read &quot;10&quot; at the same time, both
        increment to 11, and set the new value of 11. The final value will always be 
        12 and the read-increment-set operation is performed while all the other
        clients are not executing a command at the same time.</p>
        
        <p>There are a number of commands operating on strings. For example
        the <a href="../commands/getset.html">GETSET</a> command sets a key to a new value, returning the old value as
        result. You can use this command, for example, if you have a
        system that increments a Redis key using <a href="../commands/incr.html">INCR</a>
        every time your web site receives a new visit. You want to collect this
        information one time every hour, without losing a single increment.
        You can <a href="../commands/getset.html">GETSET</a> the key, assigning it the new value of &quot;0&quot; and reading the
        old value back.</p>
        
        <p>The ability to set or retrieve the value of multiple keys in a single
        command is also useful for reduce latency. For this reason there are
        the <a href="../commands/mset.html">MSET</a> and <a href="../commands/mget.html">MGET</a> commands:</p>
        
        <pre><code>&gt; mset a 10 b 20 c 30&#x000A;OK&#x000A;&gt; mget a b c&#x000A;1) &quot;10&quot;&#x000A;2) &quot;20&quot;&#x000A;3) &quot;30&quot;&#x000A;</code></pre>
        
        <p>When <a href="../commands/mset.html">MSET</a> is used, Redis returns an array of values.</p>
        
        <h2>Altering and querying the key space</h2>
        
        <p>There are commands that are not defined on particular types, but are useful
        in order to interact with the space of keys, and thus, can be used with
        keys of any type.</p>
        
        <p>For example the <a href="../commands/exists.html">EXISTS</a> command returns 1 or 0 to signal if a given key
        exists or not in the data base, while the <a href="../commands/del.html">DEL</a> command deletes a key
        and associated value, whatever the value is.</p>
        
        <pre><code>&gt; set mykey hello&#x000A;OK&#x000A;&gt; exists mykey&#x000A;(integer) 1&#x000A;&gt; del mykey&#x000A;(integer) 1&#x000A;&gt; exists mykey&#x000A;(integer) 0&#x000A;</code></pre>
        
        <p>From the examples you can also see how <a href="../commands/del.html">DEL</a> itself returns 1 or 0 whatever
        the key was removed (it existed) or not (there was no such key with that
        name).</p>
        
        <p>There are many key space related commands, but the above two are the
        essential ones together with the <a href="../commands/type.html">TYPE</a> command, that returns the kind
        of value stored at the specified key:</p>
        
        <pre><code>&gt; set mykey x&#x000A;OK&#x000A;&gt; type mykey&#x000A;string&#x000A;&gt; del mykey&#x000A;(integer) 1&#x000A;&gt; type mykey&#x000A;none&#x000A;</code></pre>
        
        <h2>Redis expires: keys with limited time to live</h2>
        
        <p>Before to continue with more complex data structures, we need to expose
        another feature which works regardless of the value type, and is
        called <strong>Redis expires</strong>. Basically you can set a timeout to a key, which
        is, a limited time to live. When the time to live elapsed, the key is
        automatically destroyed, exactly like if the user called the <a href="../commands/del.html">DEL</a> command
        with the key.</p>
        
        <p>A few quick info about Redis expires:</p>
        
        <ul>
        <li>They can be set both using seconds or milliseconds precision.</li>
        <li>However the expire time resolution is always 1 millisecond.</li>
        <li>Information about expires are replicated and persisted on disk, the time virtually passes when your Redis server remains stopped (this means that Redis saves the date at which a key will expire).</li>
        </ul>
        
        <p>Setting an expire is trivial:</p>
        
        <pre><code>&gt; set key some-value&#x000A;OK&#x000A;&gt; expire key 5&#x000A;(integer) 1&#x000A;&gt; get key (immediately)&#x000A;&quot;some-value&quot;&#x000A;&gt; get key (after some time)&#x000A;(nil)&#x000A;</code></pre>
        
        <p>The key vanished between the two <a href="../commands/get.html">GET</a> calls, since the second call was
        delayed more than 5 seconds. In the example above we used <a href="../commands/expire.html">EXPIRE</a> in
        order to set the expire (it can also be used in order to set a different
        expire to a key already having one, like <a href="../commands/persist.html">PERSIST</a> can be used in order
        to remove the expire and make the key persistent forever). However we
        can also create keys with expires using other Redis commands. For example
        using <a href="../commands/set.html">SET</a> options:</p>
        
        <pre><code>&gt; set key 100 ex 10&#x000A;OK&#x000A;&gt; ttl key&#x000A;(integer) 9&#x000A;</code></pre>
        
        <p>The example above sets a key with the string value <code>100</code>, having an expire
        of ten seconds. Later the <a href="../commands/ttl.html">TTL</a> command is called in order to check the
        remaining time to live for the key.</p>
        
        <p>In order to set and check expires in milliseconds, check the <a href="../commands/pexpire.html">PEXPIRE</a>
        the <a href="../commands/pttl.html">PTTL</a> commands, and the full list of <a href="../commands/set.html">SET</a> options.</p>
        
        <p><a name="lists"></a></p>
        
        <h2>Redis Lists</h2>
        
        <p>To explain the List data type it&#39;s better to start with a little bit of theory,
        as the term <em>List</em> is often used in an improper way by information technology
        folks. For instance &quot;Python Lists&quot; are not what the name may suggest (Linked
        Lists), they are actually Arrays (the same data type is called Array in
        Ruby actually).</p>
        
        <p>From a very general point of view a List is just a sequence of ordered
        elements: 10,20,1,2,3 is a list. But the properties of a List implemented using
        an Array are very different from the properties of a List implemented using a
        <em>Linked List</em>.</p>
        
        <p>Redis lists are implemented via Linked Lists. This means that even if you have
        millions of elements inside a list, the operation of adding a new element in
        the head or in the tail of the list is performed <em>in constant time</em>. Adding a
        new element with the <a href="../commands/lpush.html">LPUSH</a> command to the head of a ten
        elements list is the same speed as adding an element to the head of a 10
        million elements list.</p>
        
        <p>What&#39;s the downside? Accessing an element <em>by index</em> is very fast in lists
        implemented with an Array (constant time indexed access) and not so fast in
        lists implemented by linked lists (where the operation requires an amount of
        work proportional to the index of the accessed element).</p>
        
        <p>Redis Lists are implemented with linked lists because for a database system it
        is crucial to be able to add elements to a very long list in a very fast way.
        Another strong advantage is, as you&#39;ll see in a moment, that Redis Lists can be
        taken at constant length in constant time.</p>
        
        <p>When fast access to the middle of a large collection of elements is important,
        there is a different data structure that can be used, called sorted sets. Sorted sets will be covered later in this tutorial.</p>
        
        <h2>First steps with Redis Lists</h2>
        
        <p>The <a href="../commands/lpush.html">LPUSH</a> command adds a new element into a list, on the
        left (at the head), while the <a href="../commands/rpush.html">RPUSH</a> command adds a new
        element into a list, on the right (at the tail). Finally the
        <a href="../commands/lrange.html">LRANGE</a> command extracts ranges of elements from lists:</p>
        
        <pre><code>&gt; rpush mylist A&#x000A;(integer) 1&#x000A;&gt; rpush mylist B&#x000A;(integer) 2&#x000A;&gt; lpush mylist first&#x000A;(integer) 3&#x000A;&gt; lrange mylist 0 -1&#x000A;1) &quot;first&quot;&#x000A;2) &quot;A&quot;&#x000A;3) &quot;B&quot;&#x000A;</code></pre>
        
        <p>Note that <a href="../commands/lrange.html">LRANGE</a> takes two indexes, the first and the last
        element of the range to return. Both the indexes can be negative to tell Redis
        to start to count from the end, so -1 is the last element, -2 is the
        penultimate element of the list, and so forth.</p>
        
        <p>As you can see <a href="../commands/rpush.html">RPUSH</a> appended the elements on the right of the list, while
        the final <a href="../commands/lpush.html">LPUSH</a> appended the element on the left.</p>
        
        <p>Both commands are <em>variadic commands</em>, meaning that you are free to push
        multiple elements into a list in a single call:</p>
        
        <pre><code>&gt; rpush mylist 1 2 3 4 5 &quot;foo bar&quot;&#x000A;(integer) 9&#x000A;&gt; lrange mylist 0 -1&#x000A;1) &quot;first&quot;&#x000A;2) &quot;A&quot;&#x000A;3) &quot;B&quot;&#x000A;4) &quot;1&quot;&#x000A;5) &quot;2&quot;&#x000A;6) &quot;3&quot;&#x000A;7) &quot;4&quot;&#x000A;8) &quot;5&quot;&#x000A;9) &quot;foo bar&quot;&#x000A;</code></pre>
        
        <p>An important operation defined on Redis lists is the ability to <em>pop elements</em>.
        Popping elements is the operation of retrieving the element from the list,
        and eliminating it from the list, at the same time. You can pop elements
        from left and right, similarly to how you can push elements in both sides
        of the list:</p>
        
        <pre><code>&gt; rpush mylist a b c&#x000A;(integer) 3&#x000A;&gt; rpop mylist&#x000A;&quot;c&quot;&#x000A;&gt; rpop mylist&#x000A;&quot;b&quot;&#x000A;&gt; rpop mylist&#x000A;&quot;a&quot;&#x000A;</code></pre>
        
        <p>We added three elements and popped three elements, so at the end of this
        sequence of commands the list is empty and there are no more elements to
        pop. If we try to pop yet another element, this is the result we get:</p>
        
        <pre><code>&gt; rpop mylist&#x000A;(nil)&#x000A;</code></pre>
        
        <p>Redis returned a NULL value to signal that there are no elements into the
        list.</p>
        
        <h2>Common use cases for lists</h2>
        
        <p>Lists are useful for a number of tasks, two very representative use cases
        are the following:</p>
        
        <ul>
        <li>Remember the latest updates posted by users into a social network.</li>
        <li>Communication between processes, using a consumer-producer pattern where the producer pushes items into a list, and a consumer (usually a <em>worker</em>) consumes those items executing actions. Redis has special list commands to make this use case both more reliable and efficient.</li>
        </ul>
        
        <p>For example both the popular Ruby libraries <a href="https://github.com/resque/resque">resque</a> and <a href="https://github.com/mperham/sidekiq">sidekiq</a> use Redis lists under the hoods in order to implement background jobs.</p>
        
        <p>The popular Twitter social network <a href="http://www.infoq.com/presentations/Real-Time-Delivery-Twitter">takes the latest tweets</a> posted by users into Redis lists.</p>
        
        <p>To describe a common use case step by step, imagine you want to speedup the
        list of the latest published photos in the home page of your photo sharing
        social network.</p>
        
        <ul>
        <li>Every time an user posts a new photo, we add its ID into a list with <a href="../commands/lpush.html">LPUSH</a>.</li>
        <li>When users visit the home page, we use <code>LRANGE 0 9</code> in order to get the latest 10 posted items.</li>
        </ul>
        
        <h2>Capped lists</h2>
        
        <p>In many use cases we just want to use lists to store the <em>latest items</em>,
        whatever they are: social network updates, logs, or anything else.</p>
        
        <p>Redis allows to use lists as a capped collection, only remembering the latest
        N items and discarding all the oldest items using the <a href="../commands/ltrim.html">LTRIM</a> command.</p>
        
        <p>The <a href="../commands/ltrim.html">LTRIM</a> command is similar to <a href="../commands/lrange.html">LRANGE</a>, but <strong>instead of displaying the
        specified range of elements</strong> it sets this range as the new list value. All
        the elements outside the given range are removed.</p>
        
        <p>An example will make it more clear:</p>
        
        <pre><code>&gt; rpush mylist 1 2 3 4 5&#x000A;(integer) 5&#x000A;&gt; ltrim mylist 0 2&#x000A;OK&#x000A;&gt; lrange mylist 0 -1&#x000A;1) &quot;1&quot;&#x000A;2) &quot;2&quot;&#x000A;3) &quot;3&quot;&#x000A;</code></pre>
        
        <p>The above <a href="../commands/ltrim.html">LTRIM</a> command tells Redis to take just list elements from index
        0 to 2, everything else will be discarded. This makes you able to mount
        a very simple but useful patter, consisting in doing a List push operation
        + a List trim operation together in order to add a new element and discard
        exceeding elements:</p>
        
        <pre><code>LPUSH mylist &lt;some element&gt;&#x000A;LTRIM mylist 0 999&#x000A;</code></pre>
        
        <p>The above combination of elements add a new element taking only the 1000
        newest elements into the list. With <a href="../commands/lrange.html">LRANGE</a> you can access the top items
        without any need to remember very old data.</p>
        
        <p>Note: while <a href="../commands/lrange.html">LRANGE</a> is technically an <span class="math">O(N) </span>command, accessing small ranges
        towards the head or the tail of the list, is a constant time operation.</p>
        
        <h2>Blocking operations on lists</h2>
        
        <p>Lists have a special feature that make them suitable to implement queues,
        and in general as a building block for inter process communication systems:
        blocking operations.</p>
        
        <p>Imagine you want to push items into a list with one process, and use
        a different process in order to actually make some kind of work with those
        items. This is the usual producer / consumer setup, that can be implemented
        in the following simple way:</p>
        
        <ul>
        <li>To push items into the list, producers call <a href="../commands/lpush.html">LPUSH</a>.</li>
        <li>To extract / process items from the list, consumers call <a href="../commands/rpop.html">RPOP</a>.</li>
        </ul>
        
        <p>However it is possible that sometimes the list is empty and there is nothing
        to process, so <a href="../commands/rpop.html">RPOP</a> just returns NULL. So a consumer is forced to wait
        some time and retry again with <a href="../commands/rpop.html">RPOP</a>. This is called <em>polling</em>, and is not
        a good idea in this context because it has several drawbacks:</p>
        
        <ol>
        <li>Forces Redis and clients to process useless commands (all the requests when the list is empty will get no actual work done, they&#39;ll just return NULL).</li>
        <li>Adds a delay to the processing of items, since after a worker receives a NULL, it waits some time. To make the delay smaller, we could wait less between calls to <a href="../commands/rpop.html">RPOP</a>, with the effect of aggravating more problem number 1: more useless calls to Redis.</li>
        </ol>
        
        <p>So Redis implements commands called <a href="../commands/brpop.html">BRPOP</a> and <a href="../commands/blpop.html">BLPOP</a> which are versions
        of <a href="../commands/rpop.html">RPOP</a> and <a href="../commands/lpop.html">LPOP</a> able to block if the list is empty: they&#39;ll return to
        the caller only when a new element is added to the list, or when an user
        specified timeout is reached.</p>
        
        <p>This is an example of <a href="../commands/brpop.html">BRPOP</a> call we could use in the worker:</p>
        
        <pre><code>&gt; brpop tasks 5&#x000A;1) &quot;tasks&quot;&#x000A;2) &quot;do_something&quot;&#x000A;</code></pre>
        
        <p>It means: &quot;wait for elements in the list <code>tasks</code>, but return if after 5 seconds
        no element is available&quot;.</p>
        
        <p>Note that you can use 0 as timeout to wait forever for elements, and you can
        also specify multiple lists and not just one, in order to wait into multiple
        lists at the same time, and get notified when the first list receives an
        element.</p>
        
        <p>A few things to note about <a href="../commands/brpop.html">BRPOP</a>.</p>
        
        <ol>
        <li>Clients are served in an ordered way: the first client that blocked waiting for a list, is served the first when an element is pushed by some other client, and so forth.</li>
        <li>The return value is different compared to <a href="../commands/rpop.html">RPOP</a>: it is a two elements array since it also includes the name of the key, because <a href="../commands/brpop.html">BRPOP</a> and <a href="../commands/blpop.html">BLPOP</a> are able to block waiting for elements from multiple lists.</li>
        <li>If the timeout is reached, NULL is returned.</li>
        </ol>
        
        <p>There are more things you should know about lists and blocking ops. We
        suggest you to read the following pages:</p>
        
        <ul>
        <li>It is possible to build safer queues or rotating queues using <a href="../commands/rpoplpush.html">RPOPLPUSH</a>.</li>
        <li>There is also a blocking variant of the command, called <a href="../commands/brpoplpush.html">BRPOPLPUSH</a>.</li>
        </ul>
        
        <h2>Automatically creation and removal of keys</h2>
        
        <p>So far in our examples we never had to create empty lists before pushing
        elements, or removing empty lists when they no longer have elements inside.
        It is Redis care to delete keys when lists are left empty, or to create
        an empty list if the key does not exist and we are trying to add elements
        to it, for example, with <a href="../commands/lpush.html">LPUSH</a>.</p>
        
        <p>This is not specific to lists, it applies to all the Redis data types
        composed of multiple elements, so also applies to Sets, Sorted Sets and
        Hashes.</p>
        
        <p>Basically we can summarize the behavior with three rules:</p>
        
        <ol>
        <li>When we add an element to an aggregate data type, if the target key does not exist, an empty aggregate data type is crated before adding the element.</li>
        <li>When we remove elements from an aggregate data type, if the value remains empty, the key is automatically destroyed.</li>
        <li>Calling a read-only command such as <a href="../commands/llen.html">LLEN</a> (which returns the length of the list), or a write command removing elements, with an empty key, always produces the same result as if the key is holding an empty aggregate type of the type the command expects to find.</li>
        </ol>
        
        <p>Examples of rule 1:</p>
        
        <pre><code>&gt; del mylist&#x000A;(integer) 1&#x000A;&gt; lpush mylist 1 2 3&#x000A;(integer) 3&#x000A;</code></pre>
        
        <p>However we can&#39;t perform operations against the wrong type of the key exists:</p>
        
        <pre><code>&gt; set foo bar&#x000A;OK&#x000A;&gt; lpush foo 1 2 3&#x000A;(error) WRONGTYPE Operation against a key holding the wrong kind of value&#x000A;&gt; type foo&#x000A;string&#x000A;</code></pre>
        
        <p>Example of rule 2:</p>
        
        <pre><code>&gt; lpush mylist 1 2 3&#x000A;(integer) 3&#x000A;&gt; exists mylist&#x000A;(integer) 1&#x000A;&gt; lpop mylist&#x000A;&quot;3&quot;&#x000A;&gt; lpop mylist&#x000A;&quot;2&quot;&#x000A;&gt; lpop mylist&#x000A;&quot;1&quot;&#x000A;&gt; exists mylist&#x000A;(integer) 0 &#x000A;</code></pre>
        
        <p>The key does no longer exist after all the elements are popped.</p>
        
        <p>Example of rule 3:</p>
        
        <pre><code>&gt; del mylist&#x000A;(integer) 0&#x000A;&gt; llen mylist&#x000A;(integer) 0&#x000A;&gt; lpop mylist&#x000A;(nil)&#x000A;</code></pre>
        
        <p><a name="hashes"></a></p>
        
        <h2>Redis Hashes</h2>
        
        <p>Redis hashes look like exactly how you expect an &quot;hash&quot; to look like:</p>
        
        <pre><code>&gt; hmset user:1000 username antirez birthyear 1977 verified 1&#x000A;OK&#x000A;&gt; hget user:1000 username&#x000A;&quot;antirez&quot;&#x000A;&gt; hget user:1000 birthyear&#x000A;&quot;1977&quot;&#x000A;&gt; hgetall user:1000&#x000A;1) &quot;username&quot;&#x000A;2) &quot;antirez&quot;&#x000A;3) &quot;birthyear&quot;&#x000A;4) &quot;1977&quot;&#x000A;5) &quot;verified&quot;&#x000A;6) &quot;1&quot;&#x000A;</code></pre>
        
        <p>It is just a set of fields-values pairs. While hashes are handy to represent
        <em>objects</em>, actually the number of fields you can put inside an hash has
        no practical limits if not available memory, so you can use hashes in many
        different ways inside your application.</p>
        
        <p>The command <a href="../commands/hmset.html">HMSET</a> sets multiple fields of the hash, while <a href="../commands/hget.html">HGET</a> retrieves
        a single field. <a href="../commands/hmget.html">HMGET</a> is similar to <a href="../commands/hget.html">HGET</a> but returns an array of values:</p>
        
        <pre><code>&gt; hmget user:1000 username birthyear no-such-field&#x000A;1) &quot;antirez&quot;&#x000A;2) &quot;1977&quot;&#x000A;3) (nil)&#x000A;</code></pre>
        
        <p>There are commands that are able to perform operations on individual fields
        as well, like <a href="../commands/hincrby.html">HINCRBY</a>:</p>
        
        <pre><code>&gt; hincrby user:1000 birthyear 10&#x000A;(integer) 1987&#x000A;&gt; hincrby user:1000 birthyear 10&#x000A;(integer) 1997&#x000A;</code></pre>
        
        <p>You can find the <a href="../commands.html#hash">full list of hash commands in the documentation</a>.</p>
        
        <p>It is worth to note that small hashes (a few elements, not too big values) are
        encoded in special way in memory that make them very memory efficient.</p>
        
        <p><a name="sets"></a></p>
        
        <h2>Redis Sets</h2>
        
        <p>Redis Sets are unordered collections of strings. The
        <a href="../commands/sadd.html">SADD</a> command adds new elements to a set. It&#39;s also possible
        to do a number of other operations against sets like testing if a given element
        already exists, performing the intersection, union or difference between
        multiple sets and so forth.</p>
        
        <pre><code>&gt; sadd myset 1 2 3&#x000A;(integer) 3&#x000A;&gt; smembers myset&#x000A;1. 3&#x000A;2. 1&#x000A;3. 2&#x000A;</code></pre>
        
        <p>I added three elements to my set and told Redis to return back all the
        elements. As you can see they are not sorted, Redis is free to return the
        elements in any order at every call, since there is no contract with the
        user about elements ordering.</p>
        
        <p>We have commands to test for membership. Does a given element exists?</p>
        
        <pre><code>&gt; sismember myset 3&#x000A;(integer) 1&#x000A;&gt; sismember myset 30&#x000A;(integer) 0&#x000A;</code></pre>
        
        <p>&quot;3&quot; is a member of the set, while &quot;30&quot; is not.</p>
        
        <p>Sets are good for expressing relations between objects.
        For instance we can easily use sets in order to implement tags.</p>
        
        <p>A simple way to model this problem is to have a set for every object we
        want to tag. The set contains the IDs of the tags associated with the object.</p>
        
        <p>Imagine we want to tag news.
        If our news ID 1000 is tagged with tag 1,2,5 and 77, we can have one set
        associating our tag IDs with the news:</p>
        
        <pre><code>&gt; sadd news:1000:tags 1 2 5 77&#x000A;(integer) 4&#x000A;</code></pre>
        
        <p>However sometimes I may want to have the inverse relation as well: the list
        of all the news tagged with a given tag:</p>
        
        <pre><code>&gt; sadd tag:1:news 1000&#x000A;(integer) 1&#x000A;&gt; sadd tag:2:news 1000&#x000A;(integer) 1&#x000A;&gt; sadd tag:5:news 1000&#x000A;(integer) 1&#x000A;&gt; sadd tag:77:news 1000&#x000A;(integer) 1&#x000A;</code></pre>
        
        <p>To get all the tags for a given object is trivial:</p>
        
        <pre><code>&gt; smembers news:1000:tags&#x000A;1. 5&#x000A;2. 1&#x000A;3. 77&#x000A;4. 2&#x000A;</code></pre>
        
        <p>Note: in the example we assume you have another data structure, for example
        a Redis hash, which maps tag IDs to tag names.</p>
        
        <p>There are other non trivial operations that are still easy to implement
        using the right Redis commands. For instance we may want a list of all the
        objects with the tags 1, 2, 10, and 27 together. We can do this using
        the <a href="../commands/sinter.html">SINTER</a> command, that performs the intersection between different
        sets. We can just use:</p>
        
        <pre><code>&gt; sinter tag:1:news tag:2:news tag:10:news tag:27:news&#x000A;... results here ...&#x000A;</code></pre>
        
        <p>Intersection is not the only operation performed, you can also perform
        unions, difference, extract a random element, and so forth.</p>
        
        <p>The command to extract an element is called <a href="../commands/spop.html">SPOP</a>, and is handy to model
        certain problems. For example in order to implement a web-based poker game,
        you may want to represent your deck into a set. Imagine we use a one-char
        prefix for (C)lubs, (D)iamonds, (H)earts, (S)pades.</p>
        
        <pre><code>&gt;  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK&#x000A;   D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3&#x000A;   H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6&#x000A;   S7 S8 S9 S10 SJ SQ SK&#x000A;   (integer) 52&#x000A;</code></pre>
        
        <p>Now we want to provide each player with 5 cards. The <a href="../commands/spop.html">SPOP</a> command
        removes a random element, returning it to the client, so it is the
        perfect operation in this case.</p>
        
        <p>However if we call it against our deck directly, in the next play of the
        game we&#39;ll need to populate the deck of cards again, which may not be
        ideal. So to start, we can make a copy of the set stored in the <code>deck</code> key,
        into the <code>game:1:deck</code> key.</p>
        
        <p>This is accomplished using <a href="../commands/sunionstore.html">SUNIONSTORE</a>, which normally performs the
        intersection between multiple sets, and stores the result into anther set.
        However the intersection of a single set, is itself, so I can copy my deck
        with:</p>
        
        <pre><code>&gt; sunionstore game:1:deck deck&#x000A;(integer) 52&#x000A;</code></pre>
        
        <p>Now I&#39;m ready to provide the first player with its five cards:</p>
        
        <pre><code>&gt; spop game:1:deck&#x000A;&quot;C6&quot;&#x000A;&gt; spop game:1:deck&#x000A;&quot;CQ&quot;&#x000A;&gt; spop game:1:deck&#x000A;&quot;D1&quot;&#x000A;&gt; spop game:1:deck&#x000A;&quot;CJ&quot;&#x000A;&gt; spop game:1:deck&#x000A;&quot;SJ&quot;&#x000A;</code></pre>
        
        <p>One pair of jacks, not great...</p>
        
        <p>It is a good time to introduce the set command that provides the number
        of elements inside a set. This is often called <em>cardinality of a set</em>
        in the context of set theory, so the Redis command is called <a href="../commands/scard.html">SCARD</a>.</p>
        
        <pre><code>&gt; scard game:1:deck&#x000A;(integer) 47&#x000A;</code></pre>
        
        <p>The math works: 52 - 5 = 47.</p>
        
        <p>When you need to just get random elements without removing them from the
        set, there is the <a href="../commands/srandmember.html">SRANDMEMBER</a> command suitable for the task. It also features
        the ability to return both repeating and non-repeating elements.</p>
        
        <p><a name="sorted-sets"></a></p>
        
        <h2>Redis Sorted sets</h2>
        
        <p>Sorted sets are a data type which is similar to a mix between asSet and
        an hash. Like sets, sorted sets are composed of unique, non-repeating
        string elements, so in some sense a sorted set is a set as well.</p>
        
        <p>However while elements inside sets are not ordered, every element in
        a sorted set is associated with a floating point value, called <em>the score</em>
        (this is why the type is also similar to an hash, since every element
        is mapped to a value).</p>
        
        <p>Moreover, elements in a sorted sets are <em>taken in order</em> (so they are not
        ordered on request, order is a peculiarity of the data structure used to
        represent sorted sets). They are ordered according to the following rule:</p>
        
        <ul>
        <li>If A and B are two elements with a different score, then A &gt; B if A.score is &gt; B.score.</li>
        <li>If A and B have exactly the same score, than A &gt; B if the A string is lexicographically greater than the B string. A and B strings can&#39;t be equal since sorted sets only have unique elements.</li>
        </ul>
        
        <p>Let&#39;s start with a simple example, adding a few selected hackers names as
        sorted set elements, with their year of birth as &quot;score&quot;.</p>
        
        <pre><code>&gt; zadd hackers 1940 &quot;Alan Kay&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;&#x000A;(integer 1)&#x000A;&gt; zadd hackers 1953 &quot;Richard Stallman&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1949 &quot;Anita Borg&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1965 &quot;Yukihiro Matsumoto&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1914 &quot;Hedy Lamarr&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1916 &quot;Claude Shannon&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1969 &quot;Linus Torvalds&quot;&#x000A;(integer) 1&#x000A;&gt; zadd hackers 1912 &quot;Alan Turing&quot;&#x000A;(integer) 1&#x000A;</code></pre>
        
        <p>As you can see <a href="../commands/zadd.html">ZADD</a> is similar to <a href="../commands/sadd.html">SADD</a>, but takes one argument more
        (placed before the element to add itself), which is the score.
        <a href="../commands/zadd.html">ZADD</a> is also variadic, so you are free to specify multiple score-value
        pairs, even if this is not used in the example above.</p>
        
        <p>With sorted sets it is trivial to return a list of hackers sorted by their
        birth year because actually <em>they are already sorted</em>.</p>
        
        <p>Implementation note: Sorted sets are implemented via a
        dual-ported data structure containing both a skip list and a hash table, so
        every time we add an element Redis performs an <span class="math">O(log(N)) </span>operation. That&#39;s
        good, but when we ask for sorted elements Redis does not have to do any work at
        all, it&#39;s already all sorted:</p>
        
        <pre><code>&gt; zrange hackers 0 -1&#x000A;1) &quot;Alan Turing&quot;&#x000A;2) &quot;Hedy Lamarr&quot;&#x000A;3) &quot;Claude Shannon&quot;&#x000A;4) &quot;Alan Kay&quot;&#x000A;5) &quot;Anita Borg&quot;&#x000A;6) &quot;Richard Stallman&quot;&#x000A;7) &quot;Sophie Wilson&quot;&#x000A;8) &quot;Yukihiro Matsumoto&quot;&#x000A;9) &quot;Linus Torvalds&quot;&#x000A;</code></pre>
        
        <p>Note: 0 and -1 means from element index 0 to the last element (-1 works
        like in the case of the <a href="../commands/lrange.html">LRANGE</a> command).</p>
        
        <p>What if I want to order them the opposite way, youngest to oldest?
        Use <a href="../commands/zrevrange.html">ZREVRANGE</a> instead of <a href="../commands/zrange.html">ZRANGE</a>:</p>
        
        <pre><code>&gt; zrevrange hackers 0 -1&#x000A;1) &quot;Linus Torvalds&quot;&#x000A;2) &quot;Yukihiro Matsumoto&quot;&#x000A;3) &quot;Sophie Wilson&quot;&#x000A;4) &quot;Richard Stallman&quot;&#x000A;5) &quot;Anita Borg&quot;&#x000A;6) &quot;Alan Kay&quot;&#x000A;7) &quot;Claude Shannon&quot;&#x000A;8) &quot;Hedy Lamarr&quot;&#x000A;9) &quot;Alan Turing&quot;&#x000A;</code></pre>
        
        <p>It is possible to return scores as well, using the <code>WITHSCORES</code> argument:</p>
        
        <pre><code>&gt; zrange hackers 0 -1 withscores&#x000A;1) &quot;Alan Turing&quot;&#x000A;2) &quot;1912&quot;&#x000A;3) &quot;Hedy Lamarr&quot;&#x000A;4) &quot;1914&quot;&#x000A;5) &quot;Claude Shannon&quot;&#x000A;6) &quot;1916&quot;&#x000A;7) &quot;Alan Kay&quot;&#x000A;8) &quot;1940&quot;&#x000A;9) &quot;Anita Borg&quot;&#x000A;10) &quot;1949&quot;&#x000A;11) &quot;Richard Stallman&quot;&#x000A;12) &quot;1953&quot;&#x000A;13) &quot;Sophie Wilson&quot;&#x000A;14) &quot;1957&quot;&#x000A;15) &quot;Yukihiro Matsumoto&quot;&#x000A;16) &quot;1965&quot;&#x000A;17) &quot;Linus Torvalds&quot;&#x000A;18) &quot;1969&quot;&#x000A;</code></pre>
        
        <h2>Operating on ranges</h2>
        
        <p>Sorted sets are more powerful than this. They can operate on ranges.
        Let&#39;s get all the individuals that were born up to the 1950 inclusive. We
        use the <a href="../commands/zrangebyscore.html">ZRANGEBYSCORE</a> command to do it:</p>
        
        <pre><code>&gt; zrangebyscore hackers -inf 1950&#x000A;1) &quot;Alan Turing&quot;&#x000A;2) &quot;Hedy Lamarr&quot;&#x000A;3) &quot;Claude Shannon&quot;&#x000A;4) &quot;Alan Kay&quot;&#x000A;5) &quot;Anita Borg&quot;&#x000A;</code></pre>
        
        <p>We asked Redis to return all the elements with a score between negative
        infinity and 1950 (both extremes are included).</p>
        
        <p>It&#39;s also possible to remove ranges of elements. Let&#39;s remove all
        the hackers born between 1940 and 1960 from the sorted set:</p>
        
        <pre><code>&gt; zremrangebyscore hackers 1940 1960&#x000A;(integer) 4&#x000A;</code></pre>
        
        <p><a href="../commands/zremrangebyscore.html">ZREMRANGEBYSCORE</a> is perhaps not the best command name,
        but it can be very useful, and returns the number of removed elements.</p>
        
        <p>Another extremely useful operation defined for sorted set elements
        is the get-rank operation. It is basically possible to ask what is the
        position of an element in the set of the order elements.</p>
        
        <pre><code>&gt; zrank hackers &quot;Anita Borg&quot;&#x000A;(integer) 4&#x000A;</code></pre>
        
        <p>The <a href="../commands/zrevrank.html">ZREVRANK</a> command is also available in order to get the rank considering
        the elements sorted a descending way.</p>
        
        <h2>Lexicographical scores</h2>
        
        <p>With recent versions of Redis 2.8, a new feature was introduced that allows,
        assuming elements in a sorted set are all inserted with the same identical
        score, to get ranges lexicographically (elements are compared with the C
        <code>memcmp</code> function, so it is guaranteed that there is no collation, and every
        Redis instance will reply with the same output).</p>
        
        <p>The main commands to operate with lexicographical ranges are <a href="../commands/zrangebylex.html">ZRANGEBYLEX</a>,
        <code>ZREVRANGEBYLEX</code>, <a href="../commands/zremrangebylex.html">ZREMRANGEBYLEX</a> and <a href="../commands/zlexcount.html">ZLEXCOUNT</a>.</p>
        
        <p>For example, let&#39;s add again our list of famous hackers. But this time,
        use a score of zero for all the elements:</p>
        
        <pre><code>&gt; zadd hackers 0 &quot;Alan Kay&quot; 0 &quot;Sophie Wilson&quot; 0 &quot;Richard Stallman&quot; 0&#x000A;  &quot;Anita Borg&quot; 0 &quot;Yukihiro Matsumoto&quot; 0 &quot;Hedy Lamarr&quot; 0 &quot;Claude Shannon&quot;&#x000A;  0 &quot;Linus Torvalds&quot; 0 &quot;Alan Turing&quot;&#x000A;</code></pre>
        
        <p>Because of the sorted sets ordering rules, they are already sorted
        lexicographically:</p>
        
        <pre><code>&gt; zrange hackers 0 -1&#x000A;1) &quot;Alan Kay&quot;&#x000A;2) &quot;Alan Turing&quot;&#x000A;3) &quot;Anita Borg&quot;&#x000A;4) &quot;Claude Shannon&quot;&#x000A;5) &quot;Hedy Lamarr&quot;&#x000A;6) &quot;Linus Torvalds&quot;&#x000A;7) &quot;Richard Stallman&quot;&#x000A;8) &quot;Sophie Wilson&quot;&#x000A;9) &quot;Yukihiro Matsumoto&quot;&#x000A;</code></pre>
        
        <p>Using <a href="../commands/zrangebylex.html">ZRANGEBYLEX</a> we can ask for lexicographical ranges:</p>
        
        <pre><code>&gt; zrangebylex hackers [B [P&#x000A;1) &quot;Claude Shannon&quot;&#x000A;2) &quot;Hedy Lamarr&quot;&#x000A;3) &quot;Linus Torvalds&quot;&#x000A;</code></pre>
        
        <p>Ranges can be inclusive or exclusive (depending on the first character),
        also string infinite and minus infinite are specified respectively with
        the <code>+</code> and <code>-</code> strings. See the documentation for more information.</p>
        
        <p>This feature is important because allows to use sorted sets as a generic
        index. For example, if you want to index elements by a 128-bit unsigned
        integer argument, all you need to do is to add elements into a sorted
        set with the same score (for example 0) but with an 8 bytes prefix
        consisting of <strong>the 128 bit number in big endian</strong>. Since numbers in big
        endian, when ordered lexicographically (in raw bytes order) are actually
        ordered numerically as well, you can ask for ranges in the 128 bit space,
        and get the elements value discarding the prefix.</p>
        
        <p>If you want to see the feature in the context of a more serious demo,
        check the <a href="http://autocomplete.redis.io">Redis autocomplete demo</a>.</p>
        
        <h2>Updating the score: leader boards</h2>
        
        <p>Just a final note about sorted sets before switching to the next topic.
        Sorted sets scores can be updated at any time. Just calling again <a href="../commands/zadd.html">ZADD</a> against
        an element already included in the sorted set will update its score
        (and position) with <span class="math">O(log(N)) </span>time complexity, so sorted sets are suitable
        when there are tons of updates.</p>
        
        <p>Because of this characteristic a common use case is leader boards.
        The typical application is a Facebook game where you combine the ability to
        take users sorted by their high score, plus the get-rank operation, in order
        to show the top-N users, and the user rank in the leader board (you are
        the #4932 best score here).</p>
        
        <p><a name="bitmaps"></a></p>
        
        <h2>Bitmaps</h2>
        
        <p>Bitmaps are not an actual data type, but a set of bit-oriented operations
        defined on the String type. Since strings are binary safe blobs and their
        maximum length is 512 MB, they are suitable to set up to 2<sup>32</sup> different
        bits.</p>
        
        <p>Bit operations are divided into two groups: constant-time single bit
        operations, like setting a bit to 1 or 0, or getting its value, and
        operations in group of bits, for example counting the number of set
        bits in a given range of bits (population counting).</p>
        
        <p>One of the biggest advantages of bitmaps is that they are sometimes an
        extremely space saving way to store informations. For example in a system
        where different users are represented by incremental user IDs, it is possible
        to remember a single bit information (for example if they want to receive
        or no the newsletter) of 4 million of users using just 512 MB of memory.</p>
        
        <p>Bits are set and retrieved using the <a href="../commands/setbit.html">SETBIT</a> and <a href="../commands/getbit.html">GETBIT</a> commands:</p>
        
        <pre><code>&gt; setbit key 10 1&#x000A;(integer) 1&#x000A;&gt; getbit key 10&#x000A;(integer) 1&#x000A;&gt; getbit key 11&#x000A;(integer) 0&#x000A;</code></pre>
        
        <p>The <a href="../commands/setbit.html">SETBIT</a> command takes as first argument the bit number, and as second
        argument the value to set the bit to, which is 1 or 0. The command
        automatically enlarges the string if the addressed bit is outside the
        current string length.</p>
        
        <p><a href="../commands/getbit.html">GETBIT</a> just returns the value of the bit at the specified index.
        Out of range bits (addressing a bit that is outside the length of the string
        stored into the target key) are always considered to be zero.</p>
        
        <p>There are three commands operating on group of bits:</p>
        
        <ol>
        <li><a href="../commands/bitop.html">BITOP</a> performs bit-wise operations between different strings. The provided operations are AND, OR, XOR and NOT.</li>
        <li><a href="../commands/bitcount.html">BITCOUNT</a> performs population counting, reporting the number of bits set to 1.</li>
        <li><a href="../commands/bitpos.html">BITPOS</a> finds the first bit having the specified value of 0 or 1.</li>
        </ol>
        
        <p>Both <code>BITOPS</code> and <a href="../commands/bitcount.html">BITCOUNT</a> are able to operate with byte ranges of the
        string, instead of running for the whole length of the string. The following
        is a trivial example of <a href="../commands/bitcount.html">BITCOUNT</a> call:</p>
        
        <pre><code>&gt; setbit key 0 1&#x000A;(integer) 0&#x000A;&gt; setbit key 100 1&#x000A;(integer) 0&#x000A;&gt; bitcount key&#x000A;(integer) 2&#x000A;</code></pre>
        
        <p>Common user cases for bitmaps are:</p>
        
        <ul>
        <li>Real time analytics of all kinds.</li>
        <li>Storing space efficient but high performance boolean informations associated with object IDs.</li>
        </ul>
        
        <p>For example imagine you want to know the longest streak of daily visits of
        your web site users. You start counting days starting from zero, that is the
        day you made your web site public, and set a bit with <a href="../commands/setbit.html">SETBIT</a> every time
        the user visits the web site. As a bit index you simply take the current unix
        time, subtract the initial offset, and divide by 3600*24.</p>
        
        <p>This way for each user you have a small string containing the visit
        information for each day. With <a href="../commands/bitcount.html">BITCOUNT</a> it is possible to easily get
        the number of days a given user visited the web site, while with
        a few <a href="../commands/bitpos.html">BITPOS</a> calls, or simply fetching and analyzing the bitmap client-side,
        it is possible to easily compute the longest streak.</p>
        
        <p>Bitmaps are trivial to split into multiple keys, for example for
        the sake of sharding the data set and because in general it is better to
        avoid working with huge keys. To split a bitmap across different keys
        instead of setting all the bits into a key, a trivial strategy is just
        to store M bits per key and obtain the key name with <code>bit-number/M</code> and
        the Nth bit to address inside the key with <code>bit-number MOD M</code>.</p>
        
        <p><a name="hyperloglogs"></a></p>
        
        <h2>HyperLogLogs</h2>
        
        <p>An HyperLogLog is a probabilistic data structure used in order to count
        unique things (technically this is referred to estimating the cardinality
        of a set). Usually counting unique items require to use an amount of memory
        proportional to the number of items you want to count, because you need
        to remember the elements you already seen in the past, in order to avoid
        to count them multiple times. However there is a set of algorithms that trade
        memory for precision: you end with an estimated measure, with a standard error,
        in the case of the Redis implementation, which is less than 1%, but the
        magic of this algorithms is that you no longer need to use an amount of memory
        proportional to the number of things counted, you just need to use a
        constant amount of memory! 12k bytes in the worst case, or a lot less if you
        HyperLogLog (We&#39;ll just call them HLL from now) has seen very few elements.</p>
        
        <p>HLLs in Redis, while technically a different data structure, is encoded
        as a Redis string, so you can call <a href="../commands/get.html">GET</a> to serialize an HLL, and <a href="../commands/set.html">SET</a>
        to un-serialize it back to the server.</p>
        
        <p>Conceptually the HLL API is like using Sets to do the same task. You would
        <a href="../commands/sadd.html">SADD</a> every observed element into a set, and would use <a href="../commands/scard.html">SCARD</a> to check the
        number of elements inside the set, which are unique since <a href="../commands/scard.html">SCARD</a> will not
        re-add an already added element.</p>
        
        <p>While you don&#39;t really <em>add items</em> into an HLL, because the data structure
        only contains a state that does not include actual elements, the API is the
        same:</p>
        
        <ul>
        <li>Every time you see a new element, you add it to the count with <a href="../commands/pfadd.html">PFADD</a>.</li>
        <li><p>Every time you want to retrieve the current approximation of the unique elements <em>added</em> with <a href="../commands/pfadd.html">PFADD</a> so far, you use the <a href="../commands/pfcount.html">PFCOUNT</a>.</p>
        
        <blockquote>
        <p>pfadd hll a b c d
        (integer) 1
        pfcount hll
        (integer) 4</p>
        </blockquote></li>
        </ul>
        
        <p>An example of use case for this data structure is counting unique queries
        performed by users in a search form every day.</p>
        
        <p>Redis is also able to perform the union of HLLs, please check the
        <a href="../commands.html#hyperloglog">full documentation</a> for more information.</p>
        
        <h2>Other notable features</h2>
        
        <p>There are other important things in the Redis API that can&#39;t be explored
        in the context of this document, but are worth your attention:</p>
        
        <ul>
        <li>It is possible to <a href="../commands/scan.html">iterate the key space or a large collection incrementally</a>.</li>
        <li>It is possible to run <a href="../commands/eval.html">Lua scripts server side</a> to win latency and bandwidth.</li>
        <li>Redis is also a <a href="pubsub.html">Pub-Sub server</a>.</li>
        </ul>
        
        <h2>Learn more</h2>
        
        <p>This tutorial is in no way complete and has covered just the basics of the API.
        Read the <a href="../commands.html">command reference</a> to discover a lot more.</p>
        
        <p>Thanks for reading, and have a good hacking with Redis!</p>
      </article>
    </div>
    <footer>
      <p>
        This website is
        <a href="https://github.com/antirez/redis-io">open source software</a>
        developed by <a href="http://citrusbyte.com">Citrusbyte</a>.
        <br> The Redis logo was designed by <a href="http://www.carlosprioglio.com/">Carlos Prioglio</a>. See more <a href="sponsors.html">credits</a>.
      </p>
      <div class='sponsor'>
        Sponsored by
        <a href='http://www.gopivotal.com/products/redis'>
          <img alt='Redis Support' height='25' src='../images/pivotal.png' title='Redis Sponsor' width='99' />
        </a>
      </div>
    </footer>
  </body>
</html>
<script type="text/javascript">
lloogg_clientid = "20bb9c026e";
</script>
<script type="text/javascript" src="http://demo.lloogg.com/l.js?c=20bb9c026e">
</script>
